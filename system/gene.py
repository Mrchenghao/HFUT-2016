# -*- coding:utf-8 -*-

from projectManage.models import *
from system.fasta_reader import parse_fasta_str
from elasticsearch import Elasticsearch
import traceback
import urllib2
import json
from django.db.models import Q

def search_compound(keyword):
    """
    search compound based on the keyword

    @param keyword: the keyword that the user typed. Which would be used in search
    @type keyword: str
    @return: return a list that contains searched compounds
    @rtype: list
    """

    es = Elasticsearch()
    result = format_fuzzy_result(fuzzy_search_compound(es, keyword))
    return result

def fuzzy_search_compound(es, keyword):
    """
    fuzzy search compound based on the keyword with elasticsearch

    @param es: the elasticsearch object
    @param keyword: the search keyword
    @type es: Elasticsearch
    @type keyword: str
    @return a dict generated by the elasticsearch, which contains the search result
    @rtype: dict
    """

    query_body = {
        "from" : 0,
        "size" : 20,
        "query" : {
            "multi_match" : {
                "fields" : ["name"],
                "query" : keyword,
                "fuzziness" : "AUTO",
            }
        }
    }
    result = es.search(index="biodesigners", doc_type="compounds", body=query_body)
    return result

def format_fuzzy_result(es_result):
    """
    format the es search result to front end processable format

    @param es_result: the es search result
    @type es_result: dict
    @return: the front end processable format, while will be like this::
        [{'compound_id': id, 'name': name},...]
    @rtype: list
    """

    compound_result = es_result['hits']['hits']
    result = list()
    if len(compound_result) != 0:
        for compound_item in compound_result:
            info = compound_item['_source']
            compound_info = {
                'compound_id': info["compound_id"],
                'name': info['name'],
            }
            result.append(compound_info)
    return result

def get_gene_info(gid):
    """
    get gene information from the database

    @param gid: the gene id
    @ytpe gid: str
    @return: gene information dict
    @rtype: dict
    """
    base_gene_url = 'http://www.ncbi.nlm.nih.gov/gene/'
    try:
        gene_obj = Gene.objects.get(gene_id=gid)
        result = {
            'gene_id': gene_obj.gene_id,
            'name': gene_obj.name,
            'definition': gene_obj.definition,
            'organism_short': gene_obj.organism_short,
            'organism': gene_obj.organism,
            'gene_url' : base_gene_url + gene_obj.gene_id
        }
        return True, result
    except:
        traceback.print_exc()
        return False, None

def get_compound_info(cid):
    """
    get a specific compound's information

    @param cid: compound id
    @type cid: str
    @return: a tunple that contains is compound can be retrived and the information
    @rtype: dict
    """

    try:
        compound_obj = Compound.objects.get(compound_id=cid)
        result = {
            'compound_id' : compound_obj.compound_id,
            'name': compound_obj.name,
            'nicknames' : compound_obj.nicknames.replace('_', '\n'),
            'formula' : compound_obj.formula,
            'exact_mass' : compound_obj.exact_mass,
            'mol_weight' : compound_obj.mol_mass
        }
        return True, result
    except:
        traceback.print_exc()
        return False, None

class gene_graph:
    """
        gene graph, including calculation and generate of gene & protein relation graph
    """
    def __init__(self, cid_list, ogm):
        """
        constructor for gene_graph class

        @param cid_list: compound id list
        @type cid_list: str
        @param ogm: organisms
        @type ogm:str
        """
        if cid_list.startswith('_'):
            cid_list = cid_list[1:]
        if cid_list.endswith('_'):
            cid_list = cid_list[:-1]
        self.cid_list = cid_list.split('_')
        self.nodes = list()
        self.edges = list()
        self.index_dict = dict()
        self.index = 0
        if ogm != None:
            if ogm.startswith('_'):
                ogm = ogm[1:]
            if ogm.endswith('_'):
                ogm = ogm[:-1]
            self.organisms = ogm.split('_')
        else:
            self.organisms = None


    def get_compound_object(self, cid):
        """
        get compound object by compound id

        @param cid: compound id
        @type cid: str
        @return: compound object or none if not found
        @rtype: compound
        """
        try:
            compound_obj = Compound.objects.get(compound_id=cid)
            return compound_obj
        except:
            return None

    def retrive_gene_detain(self, gid):
        """
        get gene data from ncib

        @param gid: gene id
        @type gid: str
        @return: gene information in dict or none
        @rtype: dict

        """
        #get information from ncbi
        baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=gene&retmode=json&version=2.0&id='
        
        try:
            req = urllib2.Request(baseUrl + gid)
            response = urllib2.urlopen(req)
            resStr = response.read()
            result = json.loads(resStr)
            infos = result['result'][gid]
            detail_info = dict()
            detail_info['name'] = infos['name']
            detail_info['definition'] = infos['description']
            detail_info['organism'] = infos['organism']['scientificname']
            return detail_info
        except:
            traceback.print_exc()
            return None

    def related_compound(self, cid):
        """
        find a compound's related compound

        @param cid: compound id
        @type cid: str
        @return: list of related compound
        @rtype: list

        """
        compound_obj = self.get_compound_object(cid)
        if self.organisms != None:
            organism_pathway_id_list = Pathway.objects.filter(organism_id__in=self.organisms).values_list('pathway_id', flat=True)
        else:
            organism_pathway_id_list = Pathway.objects.all()
        valued_pathway_id_list = Pathway_Compound.objects.filter(pathway_id__in=organism_pathway_id_list, compound=compound_obj).values_list('pathway', flat=True)
        print valued_pathway_id_list
        valued_compound_list = Pathway_Compound.objects.filter(Q(pathway_id__in=valued_pathway_id_list), ~Q(compound=compound_obj)).values_list('compound', flat=True)
        compound_list = Compound.objects.filter(compound_id__in=valued_compound_list)
        return compound_list

    def create_node(self, name, id):
        """
        create a node (gene or compound) in the graph
        
        @param name: name for the node
        @param id: id for the node
        @type name : str
        @type id : str

        """
        node_info = {
            'name': name,
            'id': id
        }
        self.nodes.append(node_info)
        if id in self.index_dict.keys():
            return True
        self.index_dict[id] = self.index
        self.index += 1
        return True

    def create_n_link(self, center_node, compound_obj):
        """
        create nodes and link them
        @param center_node: source node
        @type center_node:compound
        @param compound_obj: compound object
        @type compound_obj: compound

        """
        gene_list = self.search_gene(compound_obj)
        for gene_id in gene_list:
            try:
                gene_obj = Gene.objects.get(gene_id=gene_id)
                if self.create_node(gene_obj.name, gene_obj.gene_id):
                    edge_info = {
                        'source' : self.index_dict[center_node],
                        'target' : self.index_dict[gene_obj.gene_id],
                        'relation' : compound_obj.name
                    }
                    self.edges.append(edge_info)
            except:
                traceback.print_exc()
                pass
        return gene_list[0]

    def get_or_create_gene(self, gid):
        """
        find gene in database, if found, return gene, or search in ncbi

        @param gid: gene id
        @type gid: str
        @return gene object
        @rtype: gene
        
        """
    #get in database
        try:
            gene_obj = Gene.objects.get(gene_id=gid)
            return gene_obj
        except:
            #get from ncbi
            baseUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=nuccore&rettype=fasta&id='
            req = urllib2.Request(baseUrl + gid)
            response = urllib2.urlopen(req)
            resStr = response.read()
            gene_dict = parse_fasta_str(resStr)
            for gn in gene_dict.keys():
                gid = gn.split('|')[1]
                #get detail information
                new_gene_obj = gene(gene_id=gid)
                detail_info = self.retrive_gene_detain(gid)
                if detail_info == None:
                    continue
                new_gene_obj.name = detail_info['name']
                new_gene_obj.definition = detail_info['definition']
                new_gene_obj.organism = detail_info['organism']
                new_gene_obj.ntseq = gene_dict[gn]
                new_gene_obj.ntseq_length = len(gene_dict[gn])
                try:
                    new_gene_obj.save()
                    return new_gene_obj
                except:
                    pass
            return None

    def save_relation_to_db(self, geneIdList, compound_obj):
        """
        save relation between compound_obj and gene to database

        @param geneIdList: gene id in a list
        @type geneIdList: list
        @param compound_obj: compound object
        @type compound_obj: compound

        """
    #create new obj
        for gid in geneIdList:
            new_rela_obj = Compound_Gene(compound=compound_obj)
            gene_obj = self.get_or_create_gene(gid)
            if gene_obj == None:
                continue
            new_rela_obj.gene = gene_obj
            try:
                new_rela_obj.save()
            except:
                pass

    def search_gene(self, compound_obj):
        """
        find gene realted to a compound

        @param compound_obj: the compound object
        @type compound_obj: compound
        @return related genes
        @rtype: list
        """
        #search in database
        obj_list = Compound_Gene.objects.filter(compound=compound_obj)
        if len(obj_list) != 0:
            geneIdList = list()
            for obj in obj_list:
                geneIdList.append(obj.gene.gene_id)
            return geneIdList[:2]
        else:
            baseGeneFindUrl = 'http://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=gene&retmode=json&term='
            try:
                req = urllib2.Request(baseGeneFindUrl + compound_obj.name)
                response = urllib2.urlopen(req)
                resStr = response.read()
            except:
                traceback.print_exc()
                return None
            if len(resStr) == 0:
                return None
            result = json.loads(resStr)
            geneIdList = result['esearchresult']['idlist']
            self.save_relation_to_db(geneIdList, compound_obj)
            return geneIdList[:2]

    def cal_graph(self):
        """
        calculate the relation graph
        """
        for cid in self.cid_list:
            center_compound_obj = self.get_compound_object(cid)
            if center_compound_obj == None:
                continue
            self.create_node(center_compound_obj.name, center_compound_obj.compound_id)
            related_list = self.related_compound(center_compound_obj.compound_id)[:5]
            for compound_obj in related_list:
                new_center = self.create_n_link(center_compound_obj.compound_id, compound_obj)
                self.create_node(compound_obj.name, compound_obj.compound_id)
                edge_info = {
                    'source': self.index_dict[center_compound_obj.compound_id],
                    'target': self.index_dict[compound_obj.compound_id],
                    'relation': compound_obj.name,
                }
                deep_related_list = self.related_compound(compound_obj.compound_id)[:2]
                for deep_compound_obj in deep_related_list:
                    self.create_n_link(compound_obj.compound_id, deep_compound_obj)

    def get_graph(self):
        """
        get the graph

        @return: th graph
        @rtype: dict
        """
        result = {
            'nodes': self.nodes,
            'edges' : self.edges
        }
        return result
